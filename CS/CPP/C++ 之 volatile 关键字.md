# C++ 之 volatile 关键字

多线程编程中经查会看到变量被定义成 volatile 的。

volatile，词典解释是，易变的。变量被它修饰的时候，往往会有被不同线程同时读写的机会，因此该变量当然是“易变的”。同时，似乎大家在这样情况下，都这样写，那么，自己也这样写，即使不知道到底有什么好处，坏处总应该是没有的。

这样子的话，总是朦朦胧胧的感觉，还是应该弄明白 volatile 到底是怎么回事。经过一番探索，也终于大概知道了个七七八八。

首先，当然地，一个变量被用 volatile 修饰与否，反映到被编译器编译后的差别，只在于生成了不同的汇编代码。虽然是不同的汇编，但是它**不会引入特殊汇编指令**，比如lock指令，或者mfence/lfence/sfence 等控制以及保证CPU做某些同步或一致性的指令。实际上差别只在于：**被 volatile 修饰的变量，每次读写它的时候，都会用内存地址来引用，而不用寄存器**；这样每次都能读到这个内存地址的实时值（否则的话，while (a == true) {...}, 如果a在寄存器中，就有可能一直死循环了）。因此，多线程编程常常用到它。

然后，根据下面所附参考中所述，volatile 还有个特性是：如果有多个变量是volatile的，那么C++中对这多个变量的先后顺序操作，在编译成汇编的时候，仍然会**把这个顺序保留在汇编中**（当然 CPU还是可能会乱序执行，但是 volatile 也只能做到这点了）。但是编译器不保证保留 volatile 变量与非 volatile 变量的这种顺序到汇编中。

另外，编译器对于与volatile 变量相关的语句，比如连续赋值（a=1; a=2;），都不会优化掉，都会保留到汇编里。

知道了这些，就可以知道， volatile 在多线程编程中确实重要；但是稍作思考又会发现，它并不能简单用于多线程的解锁(因为没有涉及到 lock，fence类指令等等，而 CPU 会乱序执行指令)。

关于例子，仿下面参考网页简单写一个如下：

```
int g_aa = 0;
volatile bool g_flag = false;
thread_1() {
    g_aa = 1;
   g_flag = true;
}
thread_2() {
    while (g_flag == true) { // 若g_flag 非volatile ，有可能编译器直接放之寄存器，都导致死循环了
       assert(g_aa == 1); // 有可能thread_1中，g_flag = true先执行，从而这里抛异常
    }
}
```

另外， volatile 的引入，本来是为了内存映射IO设备。如果编译器把这类变量优化成寄存器变量，或者把连续的两次赋值优化成一条，或者把顺序搞乱，都会导致该类 IO 设备故障。因此 volatile 变量才如此表现。

【参考】http://hedengcheng.com/?p=725
