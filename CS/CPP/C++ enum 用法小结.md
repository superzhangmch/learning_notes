# C++: enum 用法小结

C++11 对 enum 做了不少扩充，现在只说不包括 C++11的。

首先，enum 定义出来的是一个类型，只是这个类型的值范围太窄了而已。

但是，enum 定义的时候，是既可以有enum 的 name，也可以没有的：
- 有 name：
```enum e1 { e11, e21, e31};```
- 没有name：
   ```enum {e11, e21, e31};```

但是不管有没有name，导致的结果都是，在这个定义所在的作用范围内（如果定义在函数内，那么只在这个函数内生效，定义在类内作为成员，那么也只在这个类内生效），忽然多出了几个宏定义或者常量一样的东西。也就是说，不管是用上面1还是2，在这个定义之后，可以直接用e21，仿佛什么地方有“```#define e21 1```”，或 “```const int e21 =1；```”一样。

那么这个name到底有什么作用呢？其实这个name就体现在它是一个定义出来的 enum 类型名。所以一般的类型是怎样的，那么它也是怎样的。  
比如可以用来定义该类型的一个变量，承上可以“```e1 ee```”或“```e1 ee=e1；```”表示定义了一个变量ee，类型是 enum e1，其取值只能是 e11, e21, e31 三个中的一个。  
比如可以用于函数的参数 "```void f(e1 ee){}```"。

明白了以上几点，对于这样的代码：“```enum { e11, e21, e31} ee;```”，那么也就好理解多了。首先等于多出来三个宏定义或常量，其次会有一个会占用内存的变量ee，它的类型是```enum { e11, e21, e31} ```，你可以给它赋值e11，e21,e31中的任意一个。但是你没法再定义一个这样的变量了，因为ee的类型名是空的，一次性的。  
还有比如类定义中有时候会有的"```class { public: enum {num = 10}; int char[num]; }```"。也就是那么个意思而已。

另外，关于 “enum 定义会导致相当于几个宏定义或常量定义”这点，有时候你会感觉（当忘了的时候）是不是对于像“``` enum e1 {e11, e21, e31};```”，访问的时候应该"e1::e11"这样呢？这当然是不会的。因为这样子的，属于有 scope 的 enum，这个是 C++11 新增的内容（这时候需要这样定义“```enum class e1 {e11, e21, e31};```”，然后对 e11 的访问就是且只能是“```e1::e11```”了）。

【备注】
- 没法知道enum里有多少个元素。如果想知道，总是用一些古怪的方式，比如最后一个元素是一个已知名字的，然后从每个元素的取值来做减法等等来确定。
- enum 中的元素定义的时候就可以直接指定一个值。这个值是可以重复指定的,且不一定需要单调递增方式指定。比如： ```enum e{ a=1, b= 3, c = 1};```则 a 与 c 都是1.
