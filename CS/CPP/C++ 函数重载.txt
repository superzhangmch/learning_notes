# C++ 函数重载

1. const 是否构成重载  —— 看是否同时有引用或指针
对于非引用非指针参数，这个参数是否是const，是不会导致函数重载的。比如，void f(const int); 与 void f(int);  如果同时出现，就会编译报错，因为它们不构成重载。
但是如果参数是引用或指针类型的，那么这个参数是否是const，是会导致函数重载的。比如void f(const int&); 与 void f(int&); 或者void f(const int*); 与 void f(int*); ，同时出现是可以的。因为它们构成了函数重载关系。这可以解释为什么常成员函数与非常成员函数如果只差这个常，那么也可以构成重载（常成员函数的常体现在*this是 const 的）。

2. 引用是否构成重载  —— 是，但是容易导致调用歧义
对于引用来说，有没有引用是可以构成重载的。比如：void f(int); 与 void f(int&); 可以构成重载。不过就是好多时候，调用的时候会发生歧义（要么报错[我试验的是调用处报错]，要么只调用到非引用那个[看网上好多是这样]）。如果 f(1)，那么会选择都按 void f(int);，如果是 int a； int & b = a;那么无论f(a) 还是 f(b)都是会有歧义的（不要以为f(b)会通过）。看 http://stackoverflow.com/questions/5465293/function-overloading-based-on-value-vs-const-reference 给出的能消除调用歧义的方式是定义函数指针： void (*fp)(int&) = &f; fp(a); 或 fp(b);。还看到说可以对函数名强制类型转换（(void (*)(int &))f(a);）。总之是只能靠自己来选用对应重载函数，而没有啥好方法自动选择。
