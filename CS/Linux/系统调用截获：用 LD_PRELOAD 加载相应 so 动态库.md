# 系统调用截获：用 LD_PRELOAD 加载相应 so 动态库

系统调用截获的截获，当然一方面可以用 ptrace 的方式，但是还有另外一种方法可以用：
> 写一个so动态库把要替换的系统调用函数封装到里面，然后令LD_PRELOAD=这个so的方式运行源程序，就会发现系统调用已经被替换了。

这个原理是因为一般编译的时候都会默认使用动态库形式的glibc，而系统调用是被glibc封装起来的。调用系统调用的时候，都是去某个so（/lib64/libc.so.6）里找的，于是就调用到了LD_PRELOAD的库里了。

这里有个例子：http://blog.csdn.net/fisher_jiang/article/details/6783922

附带说下，就是从这个例子里，提到了怎样反gdb调试：**程序中调用ptrace(PTRACE_TRACEME,...),如果本程序正在被调用，那么该函数返回-1**。而要破除这种反调试机制，只需要把ptrace用上面的方法截获并改变默认行为就可以了。

### 【后补】
一次glibc函数出 core，没法追查，后来解决问题的方法如下：

1. 找到glibc 源码，提取相关函数的代码，做成一个简单的小so，然后用 LD_PRELOAD 方式原样运行程序，然后就运行到了小so中的同名函数，从而实现了调试。

