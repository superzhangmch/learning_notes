# linux 的 init 进程

init 进程（pid=1）是linux启动后的第一个用户空间的进程；一般的说，init启动后，内核启动就结束了。话虽这样说，但是在机器上实际查看后，总有一些令人不解的地方。

<br>

首先，有内核进/线程与非内核进/线程之分。ps 看到进程名称是"[kXXXX]"这样的都是内核进/线程。

在2.6.9内核下，看到内核进程的父进程id有的等于1，有的大于1，但是可以看到都是可以往上追朔到pid=1的进程的。

而在2.6.32内核下，看到内核进程都是由pid=2的kthreadd进程生成的。而pid=2的kthreadd进程却是由pid=0的进程生成的。

总之，两种内核下，都有内核进程在init进程启动后才启动的迹象。

<br>

通过看一些资料，大概这样：2.6.9内核在执行initrd.img里的init后，还会回到内核做一些别的事，然后如何如何。这种内核下，具体怎样没有源码看几眼，不好说了；感觉像是initrd.img里的init最终把pid=1的进程启动了起来，然后怎样的把内核进程启动起来。不乱猜测了。

而2.6.32，据网上资料说是在执行initrd.img里的init后，就不再回到内核了。手头正好有源码，看了下确实这样。顺便看了下pid=2的进程怎么回事，原来这样（也结合着网上资料才理解了）：内核先把pid=1的进程启动，然后内核就接着启动kthreadd，这时候kthreadd的pid当然会大于1；而pid=1的进程启动后，其实并没有来得及做别的（比如启动init）就先在那儿hang住了，一直hang到kthreadd启动完毕，才开始做要做的事比如做一些初始化、启动init程序。由于pid=1的进程hang住等待kthreadd的启动完毕，所以kthreadd才有机会让pid=2。从这个过程看，其实完全可以先启动kthread，但这样的话，pid=1的进程就不是init了。因此才要这样曲折的启动。正由于这样的启动过程，所以看到内核进程都可以追朔pid=0，而不是1.

2014-01-11
