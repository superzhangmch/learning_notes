# linux 下的软中断

下面所说都指的是linux下。

经常见说软中断怎么怎么的，尤其多次见说到大量小包下软中断太高导致处理不过来之类的。但是到底怎样的是个软中断，一直不得其解。现在终于梳理了下，总结如下。

有软中断必然有硬中断。硬中断是很好理解的。但是软中断呢？从网上看到的资料软中断往往指的是int 指令发起的中断以及软件错误导致的cpu自己抛出的中断。这样的话，在中断处理程序看来，软中断与硬中断是没有啥区别的，因为都会对应到一个中断号。而且这时候，这样的软中断一般又叫做同步中断，而相对的硬中断，则又叫异步中断。

<br>

那么linux 下的top, mpstat 等命令里的软中断就指的这些吗？实际上从man手册里可以看到，指的是softirq。而softirq是什么呢？

通过翻看资料，大概的说，linux下处理中断的时候，是分上下两个Half的。中断上部分对应的就是一般的中断处理程序，需要处理迅速，别因此妨碍别的中断的处理。而中断下半部分对应的是softirq(ksoftirqd/[0-9]内进程与此有关), tasklet（在 softirq 基础上实现）, workqueue(events/[0-9]系统进程与此有关)这三种机制，可以做复杂的操作。下半部分是被上半部分所触发的。再通过查看了下内核源代码，得到结论是，softirq 这种软中断是与上面提到的同步中断这种软中断完全不一样的，简直八竿子打不着。另外，cat /proc/softirqs可以看到，这个softirqs 指的就是中断下半部分的softirq。

<br>

把这点搞清楚了，但是还有一点不甚清楚。就是 Top halve 的中断处理程序在处理完的时候，会触发下softirq（假设bottom halve 用了softirq而没有用 work queue），也就是说一个 interrupt 会对应到一个中断处理程序的调用，而一个中断处理程序的调用又对应一个softirq的执行触发。如果中断来的非常频繁，那么当然会导致中断处理程序忙不过来，从而导致有些中断没有被处理到。但是如果中断来的太多，以至于中断处理程序的调用都刚刚好，没有遗漏，但是softirq忙不过来呢：也就是说上一次触发的softirq还没有执行完，接着又来了同一个中断的好多个softirq，岂不是会导致 softirq 丢失。

通过分析源代码，感觉是这样：虽然 softirq 没有排队机制，但是触发 softirq 的时候，其实只是把某个softirq对应的某个bit置位，这样如果很短时间内来了非常多的softirq 触发，那么也就等于是多次bit置位而已。那这样就说明，softirq 处理函数处理的时候，本来就能一次处理掉多个中断处理程序的产出数据吧。

感觉是这样。
