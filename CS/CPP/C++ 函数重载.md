# C++ 函数重载

### 1. const 是否构成重载  —— 看是否同时有引用或指针
对于非引用非指针参数，这个参数是否是const，是不会导致函数重载的。比如，```void f(const int);``` 与 ```void f(int); ``` 如果同时出现，就会编译报错，因为它们不构成重载。

但是如果参数是引用或指针类型的，那么这个参数是否是const，是会导致函数重载的。比如```void f(const int&);``` 与 ```void f(int&); ```或者```void f(const int*); ```与 ```void f(int*); ```，同时出现是可以的。因为它们构成了函数重载关系。这可以解释为什么常成员函数与非常成员函数如果只差这个常，那么也可以构成重载（常成员函数的常体现在*this是 const 的）。

### 2. 引用是否构成重载  —— 是，但是容易导致调用歧义
对于引用来说，有没有引用是可以构成重载的。比如：```void f(int); ```与``` void f(int&); ```可以构成重载。不过就是好多时候，调用的时候会发生歧义（要么报错[我试验的是调用处报错]，要么只调用到非引用那个[看网上好多是这样]）。如果 f(1)，那么会选择都按``` void f(int);```，如果是 ```int a； int & b = a;```那么无论f(a) 还是 f(b)都是会有歧义的（不要以为f(b)会通过）。看 http://stackoverflow.com/questions/5465293/function-overloading-based-on-value-vs-const-reference 给出的能消除调用歧义的方式是定义函数指针： ```void (*fp)(int&) = &f; fp(a); ```或 fp(b);。还看到说可以对函数名强制类型转换:```(void (*)(int &)) f(a);```。总之是只能靠自己来选用对应重载函数，而没有啥好方法自动选择。

### 3. 函数重载的决定因素与const 也有关系
具体说是,如果某个参数是引用或指针类型，那么，它是否是const 这点，会决定是否构成重载关系。

特别的，类的成员函数是否是const成员函数，是会构成重载的（因为这个const修饰的是隐含的第一个参数,即this指针）。

注：这个需要特别注意。如果父类有个const的纯virtual函数，如果子类中覆盖定义的时候忘记了写const，那么就会发现混乱所在。因此把这个单独总结为一条吧:

### 4. 普通成员函数与常成员函数互为重载关系
因此可以同时都定义.
