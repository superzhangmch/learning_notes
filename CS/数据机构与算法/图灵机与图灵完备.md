# 图灵机与图灵完备

若某物图灵完备，则足够强大。证明某东西完备，一般方法是：用它可以实现图灵机，或可以实现类似的一个比较简单的图灵完备的东西（比如 brainfuck）。

### 图灵机的程序并不在纸带上
关于图灵机：图灵机的程序（或者说转移函数）不是写在纸带上的。在图灵机的模型中，纸带（通常被称为带子）用于存储输入、输出以及计算过程中的中间状态，而程序本身，即定义图灵机如何根据当前读取的符号和机器的当前状态来改变状态、写入符号、移动读写头的规则，是固定的，不存储在纸带上。

图灵机的程序是图灵机定义不可分割的一部分，通常被理解为图灵机的"控制器"或"控制单元"。这个控制器根据转移函数（transition function）或转移表（transition table）的规则来操作。转移函数描述了图灵机的所有可能状态、可能的输入符号、如何基于这些状态和输入符号改变状态、如何写入新的符号到带子上，以及读写头的移动方向（左、右或不动）。

因此，可以将图灵机想象为由三部分组成：一个无限长的可读写的纸带（作为存储和输入/输出），一个读写头（用于读取和写入符号，以及在纸带上移动），以及一个控制单元（包含图灵机的"程序"，即转移函数）。这种设计使得图灵机成为了一个极其强大的抽象计算模型，能够模拟任何计算过程。

### 转移表/转移函数是随着问题而变的，因为转移表就是“程序”
图灵机的转移表（或转移函数）是可以变化的，它并不是固定的一个。不同的问题需要不同的转移表来解决。转移表是图灵机程序的核心，它定义了图灵机在遇到特定状态和读取特定符号时应该如何行动，包括写入的符号、读写头的移动方向（左、右或停留不动），以及转移到的新状态。

简单来说，转移表是图灵机的“大脑”，控制着图灵机的所有操作。对于不同的计算任务，你需要设计不同的转移表来指导图灵机如何完成任务。这就像编程语言中的不同程序一样，每个程序都有其特定的指令和逻辑来解决特定的问题。

例如，如果你想用图灵机来实现简单的加法运算，你需要设计一个转移表来指导图灵机如何识别两个数字的位置、如何进行计数以及如何输出结果。而如果你想要图灵机来识别某个字符串是否为回文，你就需要一个完全不同的转移表来实现这个逻辑。

### brainFuck 语言
它的代码由以下八个字符构成：
```
> 指针右移一格
< 指针左移一格
+ 使指针当前格数值加一
- 使指针当前格数值减一
. 把当前格数值按 ASCII 表输出到终端
, 从终端接收一字节的数据，存储其 ASCII 数值到当前格
[ 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行
] 程序跳转回与之对应的 [ 处
```

这八个字符的规则本身并不直接等同于转移函数或转移表，而是可以用来构建或表示具体的转移函数/转移表。在图灵机模型中，转移函数（或转移表）定义了在给定的状态和读取到的符号下，图灵机如何改变其状态，如何移动读写头，以及如何修改纸带上的符号。而Brainfuck语言通过这八个字符提供了一种方法来实现这些操作，从而构造出具体的计算过程或算法。

简言之，Brainfuck语言中的每个字符指令都可以视为构造转移函数的基本操作或命令。通过组合这些基本操作，你可以创建出复杂的程序，这个程序的执行过程对应于图灵机根据其转移函数进行状态转移、读写操作和移动读写头的过程。

- \> 和 < 指令对应于图灵机移动读写头的操作。
- \+ 和 - 指令对应于图灵机修改纸带上符号的操作。
- . 和 , 提供了与外部环境交互（输出和输入）的能力，尽管这在传统图灵机模型中通常不直接涉及，但可以被视为扩展操作。
- [ 和 ] 指令实现了条件跳转，这类似于图灵机根据当前状态和读取的符号选择不同的转移函数条目，从而实现循环或条件执行。

因此，可以说Brainfuck程序通过这些基本操作构成了一系列具体的转移函数或转移表，这些转移函数描述了图灵机的具体行为。每个Brainfuck程序都可以看作是一个特定的图灵机，其转移函数由程序中的字符序列定义。

所以：关于“```[： 当指针当前值为 0 时，程序跳转至与之对应的 ] 之后；否则程序正常执行```”这条，假设当前在“[”，如果需要跳转到"]"之后，那就是要跳过中间的若干代码，做一个goto操作。怎样维护代码之间的位置信息，这些都是“转移表/转移函数”这个黑盒内的事而已。与纸带的移动与读取都没关。

### 【RNN 为什么图灵完备】

### 【transformer为什么图灵完备】
