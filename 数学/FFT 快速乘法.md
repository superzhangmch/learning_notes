# FFT 快速乘法

大整数乘法，按一般人思维与做法，会是 $O(n^2)$ 复杂度的，居然可以做到 $O(n \log(n))$ , 其功在于FFT离散快速傅里叶变换。  
整数的X进制表示，其实相当于一个多项式： $1023 = 1 \times 10^3+2 \times 10+3$ , 因此整数乘法可归为多项式乘法。因此下面只说多项式。

下面简述基于 FFT 的快速多项式乘法的原理。

### 乘法加速总思路框架

[知识点]：对多项式 $p(x) = a_0 + a_1 x + a_2 x^2 + .. + a_n x^n$ , 若已知 n 个不同点{ $x_1, x_2, ..., x_n$ }的n个p(x)取值，则可确定出p(x) 的各个系数（解线性方程即得）。  
现对两个n次的多项式 $p(x) = a_0 + a_1 x + a_2 x^2 + .. + a_n x^n$ 与 $q(x) = b_0 + b_1 x + b_2 x^2 + .. + b_n x^n$ , 不妨令其乘积为仍然为 n次： $prod(x) = c_0 + c_1 x + c_2 x^2 + .. + c_n x^n = p(x)q(x)$ 。对不同的n个点，若已求得prod(x)的n个取值，则prod(x) 的系数是可以求出来的（按上可知），从而多项式乘法问题得解。  
$O(n \log(n))$ 的快速多项式乘法算法，就是在以上框架下实现的（巧妙方法实现了快速求n个点的prod值，以及快速据此反求出prod(x)系数，从而得解的）。

### 需解决的问题
上面方式，有两个问题需要解决：
1. 对n个x，怎么快速求出prod(x)？
2. 当n个prod(x)求出后，怎么快速反解出prod(x)系数？
都是很耗时的计算。而 FFT 就可以化解以上问题。化解思路如下：

### FFT怎么解决以上问题的

##### 1. 对n个x，怎么快速求出prod(x)
----------------------------------
对于 { $x_1, x_2, ..., x_n$ }, 如果一个一个地求 prod(x), 确实没什么捷径。但注意两点：(1). 需要求n个，而不是1个，(2). { $x_i$ } 只要两两不同就行了，没要求一定选哪些。
[p(x_1), p(x_2), ..., p(x_n)] 可表示成矩阵与向量的乘积: Matrix{(x_i)^j} * [a_0, a_1, ..., a_n]'。这个矩阵完全是由{x_i}的幂次构成的。[n*n]矩阵乘n维向量，一般做法都是O(n^2)复杂度的。FFT要在此突破。FFT秘诀在于巧妙地选择特定{x_i}，从算n个整体上着手，而非当做n个独立向量积运算，从而把时间复杂度由O(n^2)变为O(n*log(n))。
这里只大概说下 FFT 怎么做的。
[知识点]n次单位复原根 w_n = cos(2*pi/n)+i*sin(2*pi/n) 的任意次幂所构成的集合 W_n = {w_n^i|i=0..n-1}；2n 次单位复原根 w_2n 的任意次幂构成的有 2n 个元素的集合 W_2n，包含 W_n。
特别地，FFT 选 {x_i} 为复数域n次单位原根w_n的0~n-1次方:{w_n^i|i=0..n-1}。
对n次多项式p(x)=a_0+a_1*x+..+a_n*x^n，可把偶数、奇数项合并成 p(x) = p0(x^2) + x*p1(x^2), 其中p0(x) = sum(a_{2*i} *x^i), p1(x) = sum(a_{2*i+1}*x^i)。为求 {p(w_n^i)|i=0..n-1},  归为求 {p0(w_n^(2i)|i=0..n-1} 与  {p1(w_n^(2i)|i=0..n-1}。
本来三者元素个数都是n, 由上知识点，如果n为偶数，则后两者元素个数其实是n/2，因为其实有{p0(w_n^(2i)|i=0..n-1}=={p0(w_{n/2}^i|i=0..n/2}。这就是说，FFT把计算"n个点的n次多项式求值"，转化为了求解两个"n/2个点的n/2次多项式求值"问题（注意：任意选择{x_i}，也可以用奇偶分离方式来算，但会是两个“n个点的n/2次多项式求值”问题），再加n次乘法与加法 (note: 后者计算量微不足道，而前者得到了速度翻倍)。总结为递推公式，记 f(n) 为对 p(x) 在n个点{w_n^i}的计算复杂度，那么 f(n) = 2*n + 2 * f(n/2),这导致f(n) ≈ 2*n*log(n) = O(n*log(n))【如果是任意n个点{x_i}, 则f(n) = 2*n + 2 * 2 * f(n/2), 可算出 f(n) ≈ 3 * n^2 = O(n^2)】。
现在回看，FFT用{w_n^i}得以成功，所用到的w_n的性质，就在于n个元素的{w_n^i}集合，取平方后的集合 {(w_n^i)^2|i=0..n-1}== {w_{n/2}^i|i=0..n/2-1}，只剩下了一半元素，且递归后如此逐次折半。【另外，这里没提的是，为了保证递归能进行到最后，要求n必须是2的幂次。这也是FFT所要求的】。

如果有其他方式能提供这样的性质，那么也是可以用来做多项式乘法加速的。NTT快速数论变换正是基于此。这里简述下NTT。
[预备知识点] 
(1). 对数m，如果数g满足：{g^i mod m|i=0..m-1}集合个数是m, 则g是m原根(后面对mod m都省略不记)【原根定义】
(2). 对素数p，必存在原根（但不唯一），记其一原根为g，则g^(p-1)=1 mod p，且对任意数a有 g^a = g^(a mod p-1), 也就是 f(x) = g^x 取值是以p-1为周期循环的。这和p-1次复单位原根是一模一样的。
(3). 假设 a  是p-1 的一个因数，则 {(g^i)^a | i = 0..p-1} 是 {g^i|i=0..p-1}子集, 且元素个数是(p-1)/a【(g^a)^((p-1)/a))=g^(p-1)=1, 故g^a的阶最大为(p-1)/a（阶代表不同幂次后的总取值个数）; 但也不能小于(p-1)/a, 否则存在b!=0, b 小于p-1使得g^b=1，而这是不可能的】
NTT是令 {x_i} 取为特殊值{g^i}。上面(3)其实就保证了NTT具有类似复根的折半效应。FTT矩阵是{w^(ij)}, NTT矩阵是{g^(ij)}, 前者满足w^(ij) = w^(ij mod n)，后者满足g^(ij) = g^(ij mod p-1) mod p, 这说明这两者的变换矩阵，在形式上就是一模一样的。因此只用第(2)点，也足以说明NTT之可行。
类似FFT，NTT 也是希望{(g^i)^k|i=0..p-1} 能随着k能随着依次取值{0, 2, 2^2, 2^3, ..}而折半递减到底（如此才能递推调用p(x)=p0(x*x) + x*p1(x*x)加速），这要求 p 是 p=X*2^k+1形式。
（浮点FFT容易有精度问题，NTT没精度问题，容易发生取模溢出，用不同p作多轮NTT，再用中国剩余问题把结果捞回来）

同理[q(x_1), q(x_2), ..., q(x_n)] 也可用FFT可以快速求得，从而再做一次逐点乘法，得到[prod(x_1), .., prod(x_n)].

##### 2. 当n个prod(x)求出后，怎么快速反解出prod(x)系数？
---------------------------------------------------------
仍然写成矩阵与向量乘法形式：[prod(x_1), .., prod(x_n)] = Matrix{(x_i)^j} * [c_0, c_1, ..., c_n]'。欲求出[c_0, c_1, ..., c_n], 则需要求 Matrix{(x_i)^j} 的逆，然后再乘以[prod(x_1), .., prod(x_n)]。FFT发现，这个计算仍然可以得到简化——也就是所谓的逆FFT：为了快速求n个prod(x)，{x_i^j}取值已经是单位复根的幂次了；对这个特殊矩阵，一者其逆矩阵可以提前算出，而且其形式非常好，导致可按FFT方法O(n*log(n))时间内完成逆矩阵与向量的乘积。

### 以上说了思路。下面说下具体做法：
1. 所谓快速离散傅里叶变换FFT，就是一个 $n \times n$ 特殊矩阵 M 对一个 n 维列向量 V 的线性变换，变换结果是一个 n 维列向量 MV。所谓 FFT 逆变换，就是把换一个 $n \times n$ 矩阵，其他都一样。【 FFT / 逆 FFT 就是矩阵乘法，所以只要构造好 FFT 矩阵，按矩阵运算，也能得到正确的 FFT 变换结果，只是速度上是 $O(n^2)$ 的。 FFT 正是体现在加速这个矩阵乘法上】
2. FFT 矩阵 M 第 i 行 j 列的元素就是单位 n 原根 w 的 $ij$ 次方： $a_{ij} = w^{ij}$ ,  FFT逆 $M^{-1}$ 则是 $a_{ij} = w^{-ij}/n$
3. 单位 n 原根 $w=\cos(2 \pi/n) + i \cdot \sin(2 \pi/n)$ , $\pi$ 是圆周率，i 是复数单位
（还有个快速数论变换，用到了素数的原根的性质，素数原根某些表现和复数单位根差不多，所以可同样思路来加速多项式乘法。具体就不展开了）


### 关于高精度计算

有了FFT，乘法的高精度计算就可行了。然后其他运算也是可行的了, 重点在于把其他运算也转化为乘法形式。（以下求倒数、平方根的方法可见：https://www.guokr.com/blog/444081/ ，另外后来得知如，这可以说就是通行标准做法）
比如求倒数：1/b: 对 f(x) = 1/x - b， 牛顿法【牛顿法每迭代一次，精确有效数字翻倍】可得迭代公式： $x = x (2-x b)$ 
比如除法：a/b.  先求1/b, 再用乘法4
比如开方：sqrt(a), 对 $f(x) = 1/x^2 - a$ , 牛顿法得迭代公式 $x = x + x (1 - a  x^2) / 2$ , 求得 $1/\sqrt a$ , 然后 $\sqrt a = a (1/\sqrt a)$。

另外，在高精度计算PI上，如果用marchin（马青）公式，其实是不必用到FFT的大数乘除法的。因为除的都是小数字，只需要缓存结果并依次除小数字即可。对于chudnovsky公式也类似。再另外，对这类级数展开型的公式，其实居然可以二分法使得计算急速加快。其详不述。
