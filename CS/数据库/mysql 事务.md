# mysql 事务

### 数据库事务有所谓ACID一说
- A：原子性，避免只保存一半的数据。
- D：持久性，需要落硬盘，不能断电就丢失；
- C:一致性,不能出现某种数据不一致与矛盾。这些都好理解。各种数据库，各种场合下说到事务的时候，ACD可以说都是最基本的要求。
- I：isolation，隔离性，也就是“并发”的事务之间的互相独立性——一方面容易理解，另一方面，包含着不少并不显然的内容。

使用事务的时候，ACD一般不需要作什么指定，对于I是需要指定的——当前处于哪种隔离级别。只是数据库往往处于默认的隔离级别，显得不需要制定了。

### 四种隔离级别
一般来说关系数据库有四种隔离级别，按严格程度递增依次是：
1. 读未提交(read uncommited)：本事务能读到并行事务的未提交数据(有可能rollback，所以是“脏读”);但不会有脏写（未提交的write，在commit前忽然被另一个commit的事务改写了）
2. 读已提交(read commited==RC)：本事务只能读到并行事务的已提交数据（且是及时读到，一旦提交马上读到。所以本事务内select到的值有可能前后不一致。是谓“不可重复读”）
3. 可重复读（read reapeatable==RR）：并行事务及时已经提交，本事务也读不到新值。只针对UPDATE，对于INSERT并不保证，所以并行事务如果有insert，本事务能读到的（是谓“幻读”；不过mysql通过一定机制规避了幻读了：MVCC解决了读到幻读（快照读），至于所谓间隙锁解决幻读指的是幻读导致的写问题（当前读；通过加锁，使得其他事物在这时候不能写入））。
4. 串行化（SERIALIZABLE）：各事务串行执行，从而达到了真正的隔离（注意单个sql也属于一个独立的事务）【具体实现上，如果是真正的串行，比如单线程串行执行，则无疑是满足线性一致性的；但是SERIALIZABLE只保证并发事务仿佛是按某种顺序串行执行的；对应到墙上真实事件，有些实现（比如SSI）是有可能事务内读不到已经提交的数据的】

以上提到的读，指的是“select”这种读，不指update时的先“读”后写的读。所以“可重复读”级别下，update语句执行的时候，会用当前实际最新真实值（也就是最晚的已经commit的事务的commited value）作为base；但是select却用的未必是当前实际最新真实值。(mysql中（其他db下或许也这样较），分别称之为“当前读”和“快照读”)

基于以上所说，两个并行事务之间怎样互相影响，是要看具体的实际隔离级别的。mysql默认用“可重复读”级别（看知乎说是历史原因所以与众不同），其他数据库一般默认用“读已提交”隔离级别。  
实际中，用“读已提交”已经足够。很少需要read uncommited与SERIALIZABLE这两种级别。

### 特别注意
- mysql默认是“可重复读”级别，使用不当会出bug：比如库存余量，如果select出来后代码作减法，然后把结果直接update进去（用"```update set remain =最终值```" 而不是"```update set remain = remain - 被减数```"）就可能被并行事务影响，导致结果有误。
  “可重复读”显得没啥用，还带来误导性，其用何在？网上查，一般的举例都是对账的时候，需要一个相对静止的快照一样的局面。
- 如果两个事务设计对同一数据对象的操控，则其中一个就会被锁住；事务处理不当，死锁就会发生了。

### 事务的实现
MySQL下，innoDb引擎用redo-log保证事务完整性，undo-log保证可回滚；MVCC（多版本并行控制）以及锁机制，保证各种隔离级别。

### 【一主多从的读写分离下的事务】
这时候一般需要一个数据库的proxy，所有操作发给proxy，由proxy决定每个sql应该发给主还是从。

proxy的实现，一般都是读操作发往从库，写操作发往主库。对于事务中的读（select），为了符合各种事务隔离级别，也需要发往主库的——也就是事务中的所有请求都发往主库。

对于```select for update```，一般是需要发往主库的。根据proxy的实现不同，不在事务中的单独一个```select for update```，往往可能发往从库。如果将它放到事务中，则无疑会打到主库。

作为读延迟的一种缓解优化，proxy也可能再这样做：在写/事务操作后的一定时间内的读操作，也一并发到主库。

从上知，即使读写分离下，事务也是能得到保证的。

### 分布式事务：
2pc、3pc等等。以后补

### 【开启事务后，不commit，不rollback，会怎样】
一般取决于连接所用的库在最终断开连接的时候，会补一个commit还是rollback（似乎两种都有。但是从用户角度理解，执行rollback更合理）。如果client甚至来不及补一个commit/rollback, 则server或者获知了连接的断开，从而server选择某一种默认行为；或者server连连接断开也没收到，则server一直等下去，直到某个超时吧(?), 期间相关数据对象被锁定。
如果当前请求持续很久，但是就是不commit也不rollback，那当然结果就是相关数据对象被锁定，影响并发了。
分享：
