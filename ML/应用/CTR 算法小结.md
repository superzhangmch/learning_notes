# CTR 算法小结

2017-07-09

传统上，CTR一般都用 LR 逻辑回归方法。因为可解释性强，能直接给出点击概率值，且简单可靠。

缺点是只能对特征作线性组合，缺乏非线性性。因此只使用提取出的基本特征的话，往往效果并不会很好。为了提高非线性性，需要对基本特征作变换，变换出更多特征一起参与训练。比如对于类型特征（比如user id，设备id等），可以用one hot方式，变换成n多的0/1取值的特征；发现某几个特征是相关的，那么可以对他们做笛卡尔乘积，作特征组合，一下变出好多特征；对于浮点型的特征（比如年龄）又需要离散化成多个特征（这样就不再是只能对它统一伸缩而是能不同取值不同的伸缩）。也可能是对一些特征作统计得到某些统计值后代替原特征取值。这也就是所谓的特征工程干的事。

特征组合与变换是很靠经验的一件事，所以后来发明了各种方法以解决这个问题。比如FM/FFM算法，是解决特征组合的, GBDT+LR则是用GBDT抽特新特征以扩充LR特征集。

采用以上各种特征变换/组合/扩充方法（无论人工特征组合，还是FM等自动作组合）的结果就是，本来只有可能几十个的特征，变成了成千上万上亿的特征数（因为扩充出的特征中大部分取值为0，具有稀疏性，因此又往往名其曰大规模稀疏特征）。实际上，各家互联网公司号称的n多亿的特征就是这么来的（加一个user id特征，就可能几亿了）。

以上方式得到了这么多海量的特征，导致的一个结果就是，模型的参数太多，这导致最终的模型占的内存空间太大，不方便线上实际实施。因此能训练出参数足够稀疏，也就是含非常多的0的模型就显得很有必要。L1正则化会导致更多0，是为了防止过拟合；但是这里需要更多0，则是实际工程实现的需要。为了解决这点，于是又发明了各种各样的方法，FTRL（http://blog.csdn.net/china1000/article/details/51176654 ） 就正是这样一个方法，它处理的是训练问题。

<br>

预测CTR就是预测点击概率。但是预测的概率和真实概率还是有所差距的。如果只是出top结果，即使有此差异也是无所谓的了。但广告需要平衡经济收益，往往是CTR*广告价高的才出其结果，因此不但需要给出点击率的高低排序，还需要估得尽量准。这就需要额外一个步骤，就是做点击率校正，或者说 calibration。如果样本分布和真实分布不一致，那么即使预测得很准，也是需要做calibration，校正到实际概率分布上去。

<br>

近年来深度学习盛行。如果用深度学习来作CTR，当前方法基本都可归为多层感知器的网络结构。为了应付上述大规模的稀疏特征，会用embedding的方式降维。embedding的词典大小一般不能太大。因此并不是简简单单embedding就可以的。看到有下面这些方法：
- multi-hot然后才embedding：https://mp.weixin.qq.com/s/Lf_UD92kgeTciqkHLyJmgg
- FM得到embedding：http://blog.csdn.net/xiewenbo/article/details/52038493
- 对top id 作embedding：http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45530.pdf
- id取模然后embedding：https://github.com/PaddlePaddle/models/blob/ec3f36b6d1eac414e60c2cd0949e2b83770c8e1c/ctr/dataset.md
- 关于特征离散化，特征交叉，连续特征离散化非常经典的解释: http://blog.csdn.net/lujiandong1/article/details/52412123

### 各个地方看到的经验
1. 最近分析kaggle avazu比赛前三名的解决方案的总结：
https://github.com/superzhangmch/kaggle-avazu_fork_from_3rd_code
2. 低频category特征：可以OTHER_VALUE，可以计数特征，可以hash trick。一个categorical特征如果取值太多，往往会对于出现频次少的取值统一为单独的取值 other_value。这时候可以把所有这类都归为1个取值了。其实可以根据一些特点，把这类再分为多个取值，而不只是1个取值。比如可以按计数（出现1次的是1类，2次的1类，..., n次的1类；大于n次的取原特征值）（kaggle avazu 比赛第一名就是这样处理）
3. 数值特征：离散化分桶(bin)。bin 离散化最好作统计，然后平均分桶（每个桶内样本数保持一样，所谓quantile法）
