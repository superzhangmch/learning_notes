# linux 的信号小结

linux 下的信号分为实时信号与非实时信号两种。实时信号是大于32的信号，小于32的是非实时信号（为了兼容考虑）。实时信号与非实时信号的差别很大，但是到了现在的linux，主要差别似乎就在于在信号屏蔽发的多个相同的信号在屏蔽接触后是会合成（从后面做的实验看，非屏蔽时，如果发了多个同一个的信号，在处理不过来时，也是不会处理所有发送的该信号）一个信号，还是会排队给出所有（实时信号给出所有）。

信号处理函数可以在任何时候发生。特别的要注意，如果信号处理函数内部会改动到errno，一定要先保存再退出时恢复。另外要注意一个函数是否是信号可重入的（printf就不是)。

虽然说信号处理函数可以在任何时候发生，但是实验发现：对于单线程程序，同一个信号处理函数执行过程中，是没法重新触发一个该信号的信号处理函数的(补记：经查资料发现，对于同一个信号，不会在处理过程中再触发（但是验证发现有多个线程可以重新触发到别的线程）；对于不同的信号，是可以在信号处理过程中处理别的信号的)。试验方式就是信号处理函数来一个sleep，就可以设法看了。同时发现，对于多线程程序，就可以在一个信号处理函数的处理过程中触发一个新的信号处理函数，只是这时候会触发到另外的线程上。

<br>

多线程程序在处理信号的时候，会把信号打到任意的一个线程上。但是实验发现，kill指定到某TID（线程id）后，一般会下发信号到给TID，但是如果这时候该TID的线程忙不过来，那么就会发给别的线程，从而说明实际上却是是任意选了一个线程把。另外，顺便验证了tkill 给指定线程发信号后，确实如tkill 所说的那样，会发给所指定的线程，而不会在该线程忙的时候发到别的线程。


#### 关于睡眠与信号：
经过实验发现，起码对于信号SIGALRM来说，如果进程正在睡眠，那么它对于信号不会有反应，但是一旦睡醒，就会立马处理该信号。

#### 关于 SIGCONT：
sigkill 与 sigstop 是不可以屏蔽的，而sigcont不是。在不屏蔽时，试验发现， sigcont 的处理函数会被执行，但是仍然会从睡眠中恢复。而sigkill 与 sigstop 的处理函数不会被执行。
