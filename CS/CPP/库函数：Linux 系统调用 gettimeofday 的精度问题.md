# Linux 系统调用 gettimeofday 的精度问题

根据man手册，gettimeofday返回的时间的精确度是可以精确到微秒的，也就是百万分之一秒。

而 Linux 中，关于当前日期与时间是记录在xtime这个变量中的。因此gettimeofday获得当前日期与时间的时候，是少不了从这个里面读取数据的。xtime只有在每个时钟中断的时候会更新它。按每秒1000个时钟中断算，那么xtime只有千分之一秒的精度(那么就是xtime没个时钟中断增加1000微秒；实际上，会根据adjtimex()来做微调，比如闰秒等)。那么gettimeofday是怎么做到百万分之一秒精度的呢？

其实是这样：**内核中除了时钟中断这个每隔一段时间的滴答所带来的计时外，驱动时钟中断的定时器（比如HPET高精度定时器）也有相应的计数器的**，这个计数器就可以提供比时钟中断更精确的计时，在每个时钟中断的时候，都会把这个计数器的值保存下来。所以gettimeofday返回的就是xtime中的数值，加上这个计数器的确定(当然是当前值减去保存下来的值)出来的更精确的计时。

这个计数器会从 HPET高精度计时器上的计数器，APIC电源管理计时器上的计数器，以及cpu里的时间戳计数器(time stamp counter),PIT计数器等里面选一个用，且会以这样的顺序选第一个可用的。如果机器上有 HPET高精度计时器，那么当然gettimeofday返回微秒级的时间是没啥问题的了。


### 【补充】Linux其他计时方式
- 用time()系统调用。精度低，精确到秒。
- 用rdtsc 指令。这个在上面的叙述中，如果上面的计数器就用了timestamp counter，其实就相当于用rdtsc了，但是gettimeofday毕竟是系统调用，本身开销就大，所以还是直接用rdtsc更精确。  
但是用rdtsc也会在一些情况下导致精度有误差。典型情况就是多核cpu下，可能多核的时间戳计数器不同步导致的精度问题。
