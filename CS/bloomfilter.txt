bloom filter用于集合过滤。它说属于该集合，有可能不属于，如果它说不属于该集合，则一定不属于该集合。因此它判定"属于"的时候，是有一定的误判率的。
一般来说bloom filter的误判率都是很低的。实际上，bloom filter 比较牛的一个地方在于，其误判率是可控的（有数学公式支持的概率上可控）。也就是说，对于一个集合，你可以构造具有任意误判率的一个bloom filter——当然，误判率越低，bloom filter带来的空间压缩率就越低。
其背后的理论，这里不述了，总之bloom filter的关键在于选择哈希函数个数，以及哈希表长度，使得误判率可控。只写下一个可行结果：
假设集合元素个数是Num，希望控制的错误率是Error，则：
- m_vs_n = log(1 / Error) / log(2) / log(2)  // log 以e为底。m_vs_n表示：哈希长度应该是Num的多少倍
- 哈希函数个数 k = ceil(log(2) * m_vs_n)
- 哈希长度 bit_cnt = ceil((Num * m_vs_n + 31) / 32) * 32   // 非必要。把哈希长度归约到个整长度(这里是32，可以作int类型的对其）只是为了处理方便
在一个实际例子中: 集合A元素个数是973156，其子集B元素个数是112578， 按0.001误差率对集合B构建了bloom filter。最终算得需要10个hash函数，哈希长度选为1618656，并使用了MD5(element + "_" + idx) 做哈希, idx=0.. 10。统计得，该bloom filter 会把A-B=973156-112578=860578中的877个错误分到B，877 / 860578.= 0.001019≈0.001%。说明误判率和理论预计的是一致的。

另外，有对bloom filter的一些优化——更高压缩率，更低错误率。比较有意思的一个，golomb-coded-sets，http://www.udpwork.com/item/14768.html。未深究。
