【2PC】
最著名的分布式事务，就是2PC了。
2PC中，在往下游写入而为提交前，有协调者角色，轮询下游是否可提交：若皆曰可，则逐个commit；有一个回复不允许，则全部rollback。2PC的关键在于”强协调者“的假设：协调者需要设法持久化存储状态，这样下游有任何问题，协调者都可以无限次作重试，哪怕协调者重启。因此2PC的协调者一旦出问题，就会出问题。于是诞生了3PC，在2PC的两阶段前再加一阶段，先询问各下游是否是活着的，而最后一阶段则改成超时则提交或取消。所以3PC不出问题的假设是有限时间处理（包括网络与处理，显然不现实）。
2PC是最终的强一致性的，因为设计上协调者就是不达目的誓不罢休的。而3PC，则是可能因超时出现数据不一致的。

无论2PC还是3PC，一般面对的直接下游就是database。所以它们是用于处理数据库分布式事务的。典型的一个具体例子是XA协议（好像mysql内部有用）。

下面只关注非数据库的应用层的分布式事务。

【TCC】
如果下游不是db，而是业务模块的rpc接口，同样可以按2PC的方式处理之。不过一般不太叫它2PC了。业务的分布式事务的类2PC的一个方案，叫做TCC——try，commit，cancel。TCC的下游一般都是具体的远程业务服务。对同一个功能，下游服务需要提供相应的ry，commit，cancel三个接口。先轮循作try（Try操作会做必要的业务检查及资源预留），都成功则commit，否则则统一cancel。同样需要一个类似协调者的角色，能持久化状态，也是不达目的誓不罢休的，因此TCC是很有保证的。（参看：https://www.cnblogs.com/jajian/p/10014145.html）
TCC的问题在于上游以同步方式一下多次请求下游，性能很有问题。


【基于消息队列】
化解TCC同步问题的方法是用异步方式：上游把对下游的请求直接push到一个消息队列(mq)里，然后由mq通知下游服务consume之。如果整个链条中不重不丢没失败，当然是很ok的，性能绝对很好。
但是上游作为producer往mq塞数据有可能重丢，mq通知consumer也可能重丢，如何是好！
这种时候，一般需要mq是具有消息”事务“功能的特种mq（实际上似乎大部分mq都具有这种功能）：塞数据与通知下游，都不是一个请求了事。
对于上游：先push一条状态为”not ready“的消息，然后处理自己的本地事务，如果处理ok则请求mq把刚才的消息作确认（否则同样通知mq作撤销）——直到这时候mq才可以把这条消息通知下游。这就等于是塞消息的try - commit - rolllback。如果上游一直不做commit/rollback, 那么mq可能会有机制作周期check，并通知上游。
对于下游：mq通知下游且下游处理ok后，需要回复mq，告诉mq这条数据已经被成功处理了，你可以删除它了。否则的话，mq是会做多次重试的。
通过以上机制的话（典型例子RocketMQ），事务性是确实可以得到保证的。一般可叫之为”可靠消息最终一致性方案“。（同样参看：https://www.cnblogs.com/jajian/p/10014145.html）
该异步方法假设如果总分布式事务的某部分发生不可逆转的提交，下游需要一定可以执行成功的。假如因不知不觉的某个代码bug导致了数据的不一致，下游没法成功执行，这时候只能人工处理了。

【本地消息表】
如果mq没有上面所述功能，那么就需要mq的上游自己维护mq应提供的事务相关状态。上游建立相应本地表，对该表的操作和本地业务在同一个事务内执行，这样如果本地业务ok，该表也必然有相应信息。推mq后，让下游作处理后来通知修改该表。如果上游发现该表的状态迟迟没变，则可以做重试。
该方法就是所谓的”本地消息表“。
或者即使没有mq，总之是某种方式异步提交，或者哪怕有错先记录下来，以待后续——这些都算是一种变种吧。


【其他如saga等】
saga，这个还没了解。

【总结】
2pc，tcc之类关键在于协调者记录状态，以及重试跟踪。基于mq则在于push、pop的强保证。都依赖与重试，所以下游都需要保证幂等性。如果下游注定会出错，则后者方法是没法处理的，因为没法做整体回滚。
参考：
http://tower.baidu.com/teams/9/dashboard
https://zhuanlan.zhihu.com/p/147817106
https://www.jianshu.com/p/e31d9ebed201
