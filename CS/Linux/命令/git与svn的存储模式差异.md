
## Git 与 SVN 的存储模型差异

SVN 采用的是**差量存储（delta-based storage）**模型。对于一次新的提交，SVN 通常不会完整保存所有文件内容，而是存储“基准版本 + 差异（diff）”。因此，在导出某个版本（尤其是最新版本）时，SVN 需要沿着一条 diff 链逐步重放差异，才能重构出最终文件内容。

Git 在**逻辑层面**采用的是**快照（snapshot）模型**：每一次提交在概念上都记录了整个项目工作区的状态，而不是相对于上一次提交的差异。这使得 Git 在分支、比较（diff）、检出（checkout）等操作上更加高效，也让历史结构更加清晰。

但在**物理存储层面**，Git 并不会真的为每个提交都完整复制所有文件内容。Git 的底层是一个由对象（object）组成的 DAG（有向无环图），对象包括 commit、tree 和 blob。在磁盘上，这些对象会通过 **去重（content-addressable）** 和 **delta 压缩（delta compression）** 来显著节省空间。

需要注意的是，Git **并不是按 diff 来组织历史**。即使底层使用了 delta 压缩，Git 的对象关系仍然是以完整对象为单位建模的，而不是“原始文件 + 一串补丁”的线性结构。比如，一个文件被修改了 99 次，最终在 packfile 中的存储形式既不是“1 个原始文件 + 99 个 diff”，也不是“若干完整副本 + 若干补丁”的简单组合，而是由 Git 根据启发式算法构建的一种复杂的 delta 链结构。

Git 的 delta 压缩主要发生在 **packfile** 中，通常由 `git gc` 或自动触发的打包过程完成。用户一般不需要手动调用 `git gc`，Git 会在合适的时机自动进行对象打包和压缩，将部分 blob 表示为基于其他 blob 的 delta，从而在不影响语义模型的前提下减少磁盘占用。

总结来说：

* **SVN**：

  * 逻辑模型 = 差量
  * 物理存储 = 差量
  * 历史是按 diff 链组织的

* **Git**：

  * 逻辑模型 = 快照
  * 物理存储 = 对象 + 去重 + delta 压缩
  * 历史不是 diff 链，但会在存储层使用 diff 来省空间

这种设计使 Git 在大多数以文本为主的仓库中，既保持了操作效率，又不会造成明显的空间浪费。
