# so 动态链接库及静态链接库与 gcc 选项 -fPIC

### 一、动态库与静态库区别

静态链接库（.a库）只是将一些 .o 文件用 ar 打包到一个文件里。而 ar 工具并不是只用于打包这个用的，打包任何东西都是可以的（用“```ar  fp 包名 文件列表```”就建立了，“```ar t 包名```”则能看里面有哪些文件）。所以从这个角度来说，.a库除了是个打好了的ar包以外，真是没有什么特别的。把一个 .a 库链接进可执行文件，从本质上，与直接联编.o文件是没啥区别的。

而动态链接库(.so 库)就不一样了。首先一个动态链接库就是一个 ELF 格式的文件——像一个可执行文件一样。

就是说 .a 库是用ar生成的；而.so库则是gcc直接生成的，且在链接阶段生成。

### 二、生成动态库是否必须用 -fPIC

So 库的生成需要gcc 用 ```–shared``` 选项，但是一般还需要用 ```-fPIC``` 选项。

So 库的生成其实不是必须要用```-fPIC```选项。用```-fPIC```选项只是要生成位置无关代码而已。

但是对于x64代码来说，由于其特殊性，如果要生成so库，那么必须用```-shared``` 的同时用``` -fPIC```。对于x86的32位代码，则可以用```-fPIC```也可以不用。用了```-fPIC```的话，生成的代码就是真正的共享库，可以多个进程共用物理内存中的一份库；否则的话，就做不到内存内的共享了，这时候只是做的是动态符号定位而已。

### 三、位置无关代码( -fPIC )

编译的时候用 –fPIC 当然是为了生成位置无关代码。一般用于生成动态链接库中。这样编译出来的共享库，只需要物理内存内的一个副本，就可以被多个进程加载到不同的虚拟地址空间，并安然执行。

所以能这样，我感觉最基本的在于这也一点：共享库只共享so库的.text代码段，而对于.data数据段（已初始化的全局变量，静态变量等放这里）则是各个进程准备自己的。

正由于这样，所以PIC所需的GOT / PLT 机制才能够运行。每个进程都准备好自己的.data段（GOT表在.data里面，当然由动态加载器把它设置好值），然后这个私有的 .data段会和共有的so的.text段在虚拟地址空间上相接（正好在其后面紧接），于是so的 .text 段内在引用到so外部的函数或so外部的全局变量的时候才能够直接偏移一个预先计算好的值，找到GOT 里的具体实际值。
 
### 四、GOT 与 PLT

只有动态库的时候才可能涉及到GOT 与 PLT。静态库/静态链接用不到它。

PLT 用于访问外部函数。PLT 是为了能延迟加载，第一次费时费力些但是以后就方便了，从而加速函数访问。PLT里放的是可执行代码，所以放在.text代码段里。要进行PIC式的外部函数访问时，跳转到PLT里执行，PLT里的第一句指令就是要jmp到相应的GOT表项里。GOT里的相应项会初始化以加载器的地址，所以第一次调用的时候，才能调用到加载器，并做动态解析，用真正的地址取代GOT里的原值。下一次访问的时候，仍然从PLT里的第一句的jmp指令跳转到相应的GOT项，但是这时候GOT里已经是真正的函数地址了，于是能调到真正的函数里执行了

从以上说明可见，如果so库里的函数都没有调用到外部函数，那么so库的.text段都可以没有PLT了；如果连外部全局变量也没用用到，那么都可以不用GOT了。（当然这样随便说说而已了，具体很复杂了）。

GOT 是 连接器生成的，而plt应该也是连接器生成的（从```-fPIC –S``` 生成的汇编没有看到 PLT 的）。

### 五、其他

###### 1. 只 ```–fPIC``` 而不 ```–shared```

也就是 ```–fPIC```方式生成一个.o文件。

从加 ```–S``` 生成的汇编看，会对所有的外部函数的调用换成 ```func@PLT```, 对所有的外部全局变量的引用换成 ```var@GOTPCREL```的形式。然后就这样生成了.o文件。

###### 2. 在gcc 4 + x64下：发现包含main的主文件在连接了动态库后，调用到动态库的地方的代码也是通过GOT/PLT 来做访问的：从 ```objdump –D``` 的结果看是这样的。通过 ```gcc –v``` 的过程看，一直到生成main.o 都没有与GOT/PLT 产生任何关联，但是在链接这一步后，却导致了外部调用so的地方换成了通过 PLT 方式。
