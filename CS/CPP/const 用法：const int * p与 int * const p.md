# const 用法：const int * p与 int * const p

const int * p与 int * const p 当然一般说：前者指的是p指向的东西不可变，后者则是p本身不可变。

但是想想想strlen()之类的函数，参数是 const char * s，如果按上面说的，那就是*s不可变，也就是字符串s的第一个字符不可变了。而实际上是整个字符串都不可变了。

所以 const int * p **其实指的是p这个数组的每个元素都不可变**。或者说，指的是p数组不可变，不可以通过p来修改值。

经过简单检验，也发现确实这样。

【扩展】

### 1. int (* pp)[20]的情况

int k[100][20];

const int (* pp)[20]=k; 与 int const (* pp)[20]=k; 等价，都指的是 通过pp[i][j]这种方式来修改k[100][20] 这个数组是不可能的。

而 int (* const pp)[20]=k; 则指的是 pp 本身是个常指针，只是不能改变 pp 的值，并不妨碍用来改变k的元素。

### 2. int * ppp[3]的情况

int p[3];

const int * ppp[3]={p,p,p} 指的是所指的内容(应该说指的是**不可以通过ppp来修改内容**)不可变，而指针可以变，所以再执行 ppp[0]=p 是允许的，但是 ppp[0][0]=1 是不行的。

而 int * const ppp[3]={p,p,p} 则指的是 ppp[3]这个指针数组是常的，不可以改变指针本身的值，但是可以改变指针所指向的值。

### 3. const int p[3]情况
const int p[3]={1,2,3}（注意必须初始化）后，p[1]=1是不行的，整个数组都是常的了。

下面说下为什么常成员函数必须把那个const关键词放到函数定义的圆括号后。这是因为实在没有别的地方可以放了。如果放到函数名前面的话：
```
const int cls::func(...){...} === int const  cls::func(...){...}
const int * cls::func(...){...} === int const * cls::func(...){...} !== int * const  ls::func(...){...}
```
当遇到以上情况时，这个const都用来表示返回值的类型了，所以只好放到括号后。

#### 4. int p[3]情况
注意这时候的p的值不能改变，但不能理解为p是相当于int * const 类型。实际上，p 的类型是有“三个元素的int 数组”。如果在函数中要传递p的引用应该这样写func(int (&p)[3])。
