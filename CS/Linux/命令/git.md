
## Git 与 SVN 的存储模型差异

SVN 采用的是**差量存储（delta-based storage）**模型。对于一次新的提交，SVN 通常不会完整保存所有文件内容，而是存储“基准版本 + 差异（diff）”。因此，在导出某个版本（尤其是最新版本）时，SVN 需要沿着一条 diff 链逐步重放差异，才能重构出最终文件内容。

Git 在**逻辑层面**采用的是**快照（snapshot）模型**：每一次提交在概念上都记录了整个项目工作区的状态，而不是相对于上一次提交的差异。这使得 Git 在分支、比较（diff）、检出（checkout）等操作上更加高效，也让历史结构更加清晰。

但在**物理存储层面**，Git 并不会真的为每个提交都完整复制所有文件内容。Git 的底层是一个由对象（object）组成的 DAG（有向无环图），对象包括 commit、tree 和 blob。在磁盘上，这些对象会通过 **去重（content-addressable）** 和 **delta 压缩（delta compression）** 来显著节省空间。

需要注意的是，Git **并不是按 diff 来组织历史**。即使底层使用了 delta 压缩，Git 的对象关系仍然是以完整对象为单位建模的，而不是“原始文件 + 一串补丁”的线性结构。比如，一个文件被修改了 99 次，最终在 packfile 中的存储形式既不是“1 个原始文件 + 99 个 diff”，也不是“若干完整副本 + 若干补丁”的简单组合，而是由 Git 根据启发式算法构建的一种复杂的 delta 链结构。

Git 的 delta 压缩主要发生在 **packfile** 中，通常由 `git gc` 或自动触发的打包过程完成。用户一般不需要手动调用 `git gc`，Git 会在合适的时机自动进行对象打包和压缩，将部分 blob 表示为基于其他 blob 的 delta，从而在不影响语义模型的前提下减少磁盘占用。

总结来说：

* **SVN**：

  * 逻辑模型 = 差量
  * 物理存储 = 差量
  * 历史是按 diff 链组织的

* **Git**：

  * 逻辑模型 = 快照
  * 物理存储 = 对象 + 去重 + delta 压缩
  * 历史不是 diff 链，但会在存储层使用 diff 来省空间

这种设计使 Git 在大多数以文本为主的仓库中，既保持了操作效率，又不会造成明显的空间浪费。

----

## git 是去中心化的

### Git 的“去中心化”到底是什么意思

Git 的去中心化 **不是**“没有大家常用的中心仓库”，而是：

> **从数据模型上看，Git 不存在技术上的“绝对中心”；每一个完整仓库在地位上都是对等的。**

任何一个 Git 仓库都包含：

* 完整的对象库（commit / tree / blob）
* 完整的历史关系（commit DAG）
* 可以独立创建、合并、传播历史

所谓的 *remote*，只是**本地配置中指向另一个仓库的一个名字**，不是系统级实体。

----

## Git 的真实核心：一张由 commit 构成的 DAG

1). commit 是不可变对象

* commit 的身份由 hash 决定
* hash 包含 parent 的 hash
* **任何修改都会产生新的 commit**

👉 Git 中不存在“原地修改历史”。
 
2). 全世界所有 Git commit（理论上）构成一张 DAG

* 这张 DAG 在逻辑上存在
* 但 **没人能看到全貌**
* 每个人的仓库只是这张 DAG 的一个子图

```text
Global Commit DAG (抽象存在)
 ├── Repo A 的子图
 ├── Repo B 的子图
 └── Repo C 的子图
```

###  仓库、remote、branch 都只是“视角”

1). 仓库是什么

> **仓库 = DAG 的一个子集 + 一组 refs**

* objects：你“拥有”的历史
* refs：你“承认”的历史

2). remote 是什么

> **remote 只是一个“名字 → 仓库地址”的本地映射**

* remote 不存在于历史中
* remote 不具有权威性
* `origin` 只是一个习惯名称

3). branch / HEAD 是什么

* branch 是指向某个 commit 的指针
* HEAD 是“当前你站在哪个指针上”

**权力在 refs，不在 DAG**

### Git 命令在做什么（统一视角）

从根本上看：

> **Git 的所有命令，都是在创建、复制、选择、重排、或回收 commit DAG 的一部分，以及维护指向它的 refs。**

* `commit / merge`：创建 DAG 节点
* `fetch / push`：拷贝 DAG 子图
* `rebase / amend`：生成新 DAG，抛弃旧引用
* `reset / checkout`：移动 refs
* `gc`：物理删除不可达对象

---

## Git 是否“允许改写历史”

1. 语义上的答案

> **Git 不允许真正修改历史，只允许创建新历史并改变你承认哪一段。**

所谓“改写”：

* 实际是复制旧 commit
* 改 parent / 内容
* 生成新 hash
* 旧历史仍然存在，直到被 GC

2. 极端情况也是合法的

```text
你：  1 → 8'
别人：1 → 2 → 3 → 4 → 5 → 6 → 7 → 8
```

* 两条历史可以永久并存
* 没有“最终正确版本”

3. 关于“删除历史”:

在你能控制的仓库里:

* 可以通过 `filter-repo + gc`
* 实现真正的**物理删除**

在别人仓库里:

> **你永远无法删除别人的历史**

* 除非对方主动接受新历史
* 并自行清理旧对象
* Git 不提供强制机制
