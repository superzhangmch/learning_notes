C++11引入了原子类型，以及几种内存模型。这些自然只有在多核cpu的并发情况下才起作用。
这几种原子类型，默认情况下，都是提供的顺序一致性（和分布式下的顺序一致性是一样的）——两个cpu分别写a读b与写b读a，那么不能都读到旧值。当用到原子类型时，未必需要这么强的保证，所以c++11给出了其他几种内存模型，以便一定保证下，提高并行性能。

所以需要这么周折，其中一个原因是，指令的执行顺序和c++代码中的顺序是不一样的——发生了乱序。这来自两方面：一是编译器的编译优化，导致乱序；二是cpu执行时的乱序。
编译器容易控制自己生成的指令顺序，cpu得有某种机制在必要的时候保序。

单核时代，cpu肯定是顺序一致的。多核时代，如果cpu没有cache，也就是直接操作内存，那么应该也是没啥问题的的。对于单核时代就引入的cache，在多核时，cache的跨核的一致性首先就是问题，更别提啥顺序一致性。
所以引入了缓存一致性算法——典型如MESI。总得来说，cache一致性算法如MESI保证了多核下也是有cache仿佛无cache，cache不影响程序正确，而且实现了多核下的顺序一致性。
那为啥仍然说cpu会有读写的乱序呢？这与MESI的性能导致的折中设计有关。MESI的强保证，导致其执行性能较差。重要的两点是：当要write的时候，需要确保其他核的cache失效；当要读的时候，如果本地cache line已经失效，需要重新从远端拉取。这都是很耗时的。于是现代cpu设计上，分别有相应的读、写buffer，或者说queue，学名分别叫store buffer与invalid queue。
当写的时候，先写store buffer，然后慢慢等着它执行一系列复杂操作，并最终更新到cache好了，cpu可以干别的事了。如果接着有本地读，还从这store buffer里读，但是远端这时候是读不到新值的。这时候会导致某种的读写乱序。
当远端通知本地，让本地的cache line失效的时候，或许本地还在用着它呢，于是先让它进invalid queue慢慢失效好了，而cpu则可以继续使用这本该失效的cache line。这时候也会导致某种的读写乱序。
实际上，MESI重建了顺序一致性后，而打破了顺序一致性的，就是上面的store buffer与invalid buffer。

依据程序代码中的执行顺序要求，编译器除了注意自己生成指令的顺序外，还可以指导cpu可做的，就是在适当的地方假如内存barrier，让上面两个buffer该清空禁用则禁用，从而能恢复一定的读写顺序，乃至顺序一致性。

另外，大体上cpu有两种，一种是x86这种，强顺序的；一种arm这种，弱顺序的。前者只有store buffer，且是FIFO的，于是x86类cpu，距离顺序一致性只一步之遥（只有load write乱序）。而arm这种，则是两个queue都有，且store buffer还不是FIFO的，于是各种乱序都可能产生。
