# C++: 指向成员的指针

C++ 中所有东西——变量、函数——都是可以用一个类似别名的东西来访问到，也就是说可以用一个与定义它们时不同的东西来访问到：对于变量，可以用引用，也可以用指针；对于函数，可以用函数指针。

这里说的变量，不只包括“int i”这样的变量，也包括对象与结构体，它们当然也是变量。

对于函数呢，有这么几种，普通函数，类的静态成员函数，类的成员函数，大概这么几种。对于普通函数，类的静态成员函数，当然可以很容易的用函数指针来指向它们。对于类成员函数，稍微复杂些，但起码还是容易理解的，毕竟，成员函数还是函数，理所当然有指针： 

```return_type (class_name::*func_pointer)(argument_list, ... );```

对于成员函数的指针这点，带来的一个好处是，因为可以以不同的名字来调用到成员函数，从而可以把他们放到指针数组中，用 for 语句循环调用本来需要逐个调用的成员函数。

指针本质上就是内存地址。对于变量，变量当然有存放地址；对于函数，函数代码也是存在内存中的，因此也有地址。这样看，上面所说的一切又都是合情合理的。
<br><br><br>
  
但是，仔细想想，却发现有个地方并没有那么灵活到可以换名字访问，这就是对于struct/class的数据成员的访问。比如某 class ccc有 数据成员int aa, 那么其示例xx 访问起aa来，要不用xx->aa（若xx是指针）, 要不用xx.aa, 却难以换个别的方式用xx->bb也访问到xx->aa。

实际上，还真有办法这样(用macro当然可以，但不考虑这个)。办法就是用所谓的“指向成员的指针“。

还以上面例子，定义 ```int ccc::*bb = &ccc::aa```, 然后就可以拿```*bb ```和``` aa``` 同等看待了：```xx->*bb = 1 ```和```xx->aa =1 ```是完全一样的效果。

这样子看，可真正是所有都可以换个名字来访问了。

但是，再仔细想下```int ccc::*bb = &ccc::aa```里 bb 到底指向了什么。指针一般与内存地址相对应的，那么这个bb指向什么内存地址了？但是却可以发现，**其实bb没有指向什么内存地址，它只是指向了class ccc 里的偏移而已**。那么从这个角度来说，它至少是非典型的指针。
<br><br><br>

另外，成员函数的指针其实也是”指向成员的指针“，所以其实它也属于非典型的指针的。

但是注意，指向成员函数的指针，在引用的时候应该加括号：```(obj.*func_prt)(arg1, arg2, ...)```

<hr>
【附】

指向成员的指针：定义的时候用 ``` class_name:: *p ```, 引用的时候用”.*“或”->*“算子。

例子：
```
#include< stdio.h >
struct aa{
  int a;
  int b;
  int c; 
   };
int main()
{
   aa a;
    int aa::*p[10];  // 指向成员的指针数组
   p[0] = &aa::a;
   p[1] = &aa::b;
   p[2] = &aa::c;
   int i = 0;
   for(; i< 3; i++)
   {
       a.*p[i] = i;
   }
   printf("%d %d %d\n", a.a, a.b, a.c);
   return 0;
}
```

输出：

```0 1 2```
